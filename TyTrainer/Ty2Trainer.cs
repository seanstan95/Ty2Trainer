using ControlExtension;
using Memory;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace TyTrainer
{
    public partial class Ty2Trainer : Form
    {
        //General Purpose
        readonly Mem memory = new Mem();
        const string gameName = "TY the Tasmanian Tiger 2: Bush Rescue";
        string gameVersion; //determines which list of pointers to return, can be "speedrun" or "live"
        int updateTime; //timer interval length        
        readonly StreamWriter logWriter = new StreamWriter("log.txt");
        bool verboseLogging, loggedGameStatus = false, includeY = false;
        float maxSpeed = 0;
        Label currentEffectiveSpeedLabel;

        //Persistent Game/Trainer Data
        readonly string[] modes = { "Bunyip", "Cutscene", "Heli", "Items", "Kart", "Sub", "Other", 
            "Ty", "Truck", "Unknown" };
        readonly string[] gameplayModes = { "Bunyip", "Heli", "Kart", "Sub", "Ty", "Truck" };
        Panel frontPanel;
        string currentMode; //determines what UI display to use
        string currentMusicTitle = "";
        float teleportX, teleportY, teleportZ;

        //Information From Resource Files
        readonly List<string> pointerTypes = new List<string>();
        readonly List<string> pointerNames = new List<string>();
        readonly List<string> speedrunPointerAddresses = new List<string>(), livePointerAddresses = new List<string>();
        List<string> helpTexts = new List<string>();
        readonly List<List<string>> musicTitles = new List<List<string>>(); //stores music titles by category

        //Dictionary Pairs
        readonly Dictionary<string, string> addressLabelStrings = new Dictionary<string, string>();
        readonly Dictionary<string, string> musicTitleStrings = new Dictionary<string, string>();
        readonly Dictionary<int, string> characterStateStrings = new Dictionary<int, string>();
        readonly Dictionary<string, string> featureNames = new Dictionary<string, string>()
        {
            {  "TyGroundedState", "Infinite Jump" },
            { "TySwimmingState", "Infinite Swim" }
        };

        //Hotkeys
        [DllImport("user32.dll")]
        public static extern bool RegisterHotKey(IntPtr hWnd, int id, int fsModifiers, int vlc);
        [DllImport("user32.dll")]
        public static extern bool UnregisterHotKey(IntPtr hWnd, int id);
        float XSpeed, YSpeed, ZSpeed;
        readonly List<string> customHotkeyList = new List<string>();
        readonly List<string> hotkeyNameList = new List<string>() { "XLessKey", "XMoreKey", "YLessKey",
                "YMoreKey", "ZLessKey", "ZMoreKey", "CheckPositionKey", "SetPositionKey", 
                "TeleportKey", "ResetMaxSpeedKey" };
        readonly List<Keys> keysList = Enum.GetValues(typeof(Keys)).Cast<Keys>().ToList();
        bool hotkeysEnabled = false;

        public Ty2Trainer()
        {
            Log("Initializing trainer...", "SETUP", false);
            InitializeComponent();

            //Initialize with Startup panel in front (should immediately change)
            frontPanel = (Panel)this.Controls.Find("MainPanelStartup", false)[0];
            frontPanel.BringToFront();

            //Read settings from App.config and resource .txt files
            ReadAppSettings();
            ReadResourceFiles();

            Log("Trainer initialized.", "SETUP", false);
        }

        /// <summary>
        /// Logs a message generated by the trainer. Can be changed such that only important messages are
        /// logged, or to have every generated message logged.
        /// </summary>
        /// <param name="message"></param>
        /// <param name="category"></param>
        /// <param name="verboseMessage"></param>
        private void Log(string message, string category, bool verboseMessage)
        {
            if (!verboseLogging && verboseMessage)
                return;

            string timestamp = DateTime.Now.ToString("[HH:mm:ss] ");
            logWriter.WriteLine(timestamp + category + ": " + message);
            logWriter.Flush();
        }

        /// <summary>
        /// Reads user-defined settings from App.config (mostly hotkeys)
        /// </summary>
        private void ReadAppSettings()
        {
            //timer interval + logging
            Log("Loading App.config settings...", "SETUP", false);
            updateTime = int.Parse(ConfigurationManager.AppSettings.Get("UpdateTime"));
            appTimer.Interval = updateTime;
            Log($"updateTime set to {updateTime}.", "SETUP", true);
            verboseLogging = bool.Parse(ConfigurationManager.AppSettings.Get("VerboseLogging"));
            Log($"verbose set to {verboseLogging}.", "SETUP", true);

            XSpeed = float.Parse(ConfigurationManager.AppSettings.Get("XSpeed"));
            Log($"XSpeed set to {XSpeed}.", "SETUP", true);
            YSpeed = float.Parse(ConfigurationManager.AppSettings.Get("YSpeed"));
            Log($"YSpeed set to {YSpeed}.", "SETUP", true);
            ZSpeed = float.Parse(ConfigurationManager.AppSettings.Get("ZSpeed"));
            Log($"ZSpeed set to {ZSpeed}.", "SETUP", true);

            string version = ConfigurationManager.AppSettings.Get("GameVersion");
            if(version == "live" || version == "speedrun")
            {
                gameVersion = version;
                Log($"gameVersion set to {version}.", "SETUP", true);
            }
            else
            {
                Log($"Error loading game version from App.config. Defaulting to 'speedrun'.", "SETUP", false);
                gameVersion = "speedrun";
            }

            for (int i = 0; i < hotkeyNameList.Count; ++i)
            {
                customHotkeyList.Add(ConfigurationManager.AppSettings.Get(hotkeyNameList[i]));
                Log($"{hotkeyNameList[i]} set to {customHotkeyList[i]}.", "SETUP", true);
            }

            //Verify that all entered hotkeys are valid, set to N/A if not
            for (int i = 0; i < customHotkeyList.Count; ++i)
            {
                if (!keysList.Any(key => key.ToString() == customHotkeyList[i]))
                {
                    Log($"Couldn't match hotkey {customHotkeyList[i]} to a keyboard key. This hotkey will not " +
                        "work. Check App.config and change to a valid key.", "WARNING", false);
                    customHotkeyList[i] = "N/A";
                }
            }
        }

        /// <summary>
        /// Reads resource files (.txt) and App Settings (app.config) for information such as pointers and hotkeys.
        /// </summary>
        private void ReadResourceFiles()
        {
            Log("Loading resource files...", "SETUP", false);
            Assembly asm = Assembly.GetExecutingAssembly();

            //speedrun_pointers.txt: pointer types, names, addresses for the speedrun build of the game (v112)
            Log("Reading speedrun_pointers.txt.", "SETUP", true);
            List<string> lines = GetLines(asm, "speedrun_pointers.txt");
            foreach (string line in lines)
            {
                string[] split = line.Split(' ');
                pointerTypes.Add(split[0]);
                pointerNames.Add(split[1]);
                speedrunPointerAddresses.Add(split[2]);
            }

            //live_pointers.txt: pointer types, names, addresses for the live version of the game (v1.86)
            //only handles [2] because the file is set up identically to speedrun_pointers.txt but only the pointer part is necessary
            Log("Reading live_pointers.txt.", "SETUP", true);
            lines = GetLines(asm, "live_pointers.txt");
            foreach (string line in lines)
            {
                string[] split = line.Split(' ');
                livePointerAddresses.Add(split[2]);
            }

            //music_titles.txt: lists of music titles in order of category
            Log("Reading music_titles.txt.", "SETUP", true);
            lines = GetLines(asm, "music_titles.txt");
            for (int i = 0; i < lines.Count; ++i)
            {
                List<string> newList = new List<string>(lines[i].Split(' ')); //parse each line into list of titles
                musicTitles.Add(newList);
            }

            //music_strings.txt: pairs of <music title, UI text>
            Log("Reading music_strings.txt.", "SETUP", true);
            lines = GetLines(asm, "music_strings.txt");
            foreach (string line in lines)
            {
                string[] split = line.Split(' ');
                musicTitleStrings.Add(split[0], split[1].Replace('_', ' '));
            }

            //UI_text.txt: pairs of <address name, UI text>
            Log("Reading UI_text.txt.", "SETUP", true);
            lines = GetLines(asm, "UI_text.txt");
            for (int i = 0; i < lines.Count; ++i)
                addressLabelStrings.Add(pointerNames[i], lines[i]);

            //state_strings.txt: pairs of <character state, UI text>
            Log("Reading state_strings.txt.", "SETUP", true);
            lines = GetLines(asm, "state_strings.txt");
            foreach (string line in lines)
            {
                string[] split = line.Split(' ');
                characterStateStrings.Add(int.Parse(split[0]), split[1].Replace('_', ' '));
            }

            //help_texts.txt: help texts for buttons
            Log("Reading help_texts.txt.", "SETUP", true);
            helpTexts = GetLines(asm, "help_texts.txt");
        }

        /// <summary>
        /// Takes in a file name and returns the contents in list format.
        /// </summary>
        /// <param name="asm"></param>
        /// <param name="file"></param>
        /// <returns>List of lines from given file.</returns>
        private List<string> GetLines(Assembly asm, string file)
        {
            StreamReader reader = new StreamReader(asm.GetManifestResourceStream("TyTrainer.Resources." + file));
            List<string> lines = new List<string>();
            while (!reader.EndOfStream)
                lines.Add(reader.ReadLine());
            return lines;
        }

        /// <summary>
        /// Helper method that simplifies the act of getting a pointer address given a pointer name.
        /// </summary>
        /// <param name="name"></param>
        /// <returns>The pointer address associated to the given pointer name.</returns>
        private string GetPointer(string name)
        {
            if (pointerNames.IndexOf(name) == -1)
                return "";

            if (gameVersion == "live")
                return livePointerAddresses[pointerNames.IndexOf(name)];
            else if (gameVersion == "speedrun")
                return speedrunPointerAddresses[pointerNames.IndexOf(name)];
            else
                return ""; //this will never happen (gameVersion is always "live" or "speedrun")
        }

        /// <summary>
        /// Runs every time the timer interval is reached - this is the main logic loop of the program, 
        /// handling UI updates.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TimerTick(object sender, EventArgs e)
        {
            CheckTitle();
            bool gameOpen = memory.OpenProcess("Ty2");
            if (!gameOpen)
            {
                Log("Ty2 is not open. Waiting 5 seconds and trying again.", "WARNING", false);
                loggedGameStatus = false;
                appTimer.Interval = 5000; //set timer for 5 seconds
                UpdateStatus(gameOpen);
                currentMode = "Closed";
                //LabelCurrentArea.Text = "Current Area: Game Closed!";
                if (frontPanel.Name != "MainPanelClosed")
                    UpdateUI((Panel)this.Controls.Find("MainPanelClosed", false)[0]);
                return;
            }
            else if (gameOpen && !loggedGameStatus)
            {
                Log("Ty2.exe opened.", "INFO", false);
                loggedGameStatus = true;
                appTimer.Interval = updateTime; //reset timer to user-defined time
            }

            if (GetMode())
                UpdateUI((Panel)this.Controls.Find("MainPanel" + currentMode, false)[0]);

            UpdateAreaState();
            UpdateLabels();
            UpdateMaxSpeed(false);
            UpdateStatus(gameOpen); //update closed/open status
        }

        /// <summary>
        /// Checks if Ty 2 is currently in focus or not, and registers/unregisters hotkeys as needed. This
        /// is necessary for users to be able to use their hotkey keys normally when not currently in-game.
        /// </summary>
        private void CheckTitle()
        {
            if (GetActiveWindowTitle(gameName) && !hotkeysEnabled)
            {
                RegisterKeys();
                hotkeysEnabled = true;
                Log("Hotkeys registered (game in focus).", "INFO", true);
            }
            else if (!GetActiveWindowTitle(gameName) && hotkeysEnabled)
            {
                for (int i = 0; i < hotkeyNameList.Count; ++i)
                    UnregisterHotKey(this.Handle, i);
                hotkeysEnabled = false;
                Log("Hotkeys unregistered (game out of focus).", "INFO", true);
            }
        }

        /// <summary>
        /// Retrieves the currently active window title and compares it with the given name.
        /// </summary>
        /// <param name="name"></param>
        /// <returns>True if the currently active window title matches the given name, false otherwise.</returns>
        private bool GetActiveWindowTitle(string name)
        {
            [DllImport("user32.dll")]
            static extern IntPtr GetForegroundWindow();

            [DllImport("user32.dll")]
            static extern int GetWindowText(IntPtr hWnd, StringBuilder text, int count);

            const int nChars = 256;
            StringBuilder Buff = new StringBuilder(nChars);
            IntPtr handle = GetForegroundWindow();

            if (GetWindowText(handle, Buff, nChars) > 0)
                return Buff.ToString() == name;
            return false;
        }

        /// <summary>
        /// Registers all of the hotkeys set by the user from App.config.
        /// </summary>
        private void RegisterKeys()
        {
            for (int i = 0; i < hotkeyNameList.Count; ++i)
            {
                string currentKey = customHotkeyList[i];
                if(currentKey == "N/A")
                {
                    Log("Not registering N/A hotkey.", "WARNING", true);
                    continue;
                }
                else
                {
                    int keyCode = (int)keysList.Find(key => key.ToString() == currentKey);
                    RegisterHotKey(this.Handle, i, 0x0000, keyCode);
                    Log($"Registered hotkey ({currentKey}).", "INFO", true);
                }
            }
        }

        /// <summary>
        /// Updates the maxSpeed label, allowing for it to be reset to 0 or determined based 
        /// on whether the current max speed is higher than the recorded one.
        /// </summary>
        private void UpdateMaxSpeed(bool reset)
        {
            if (!GetActiveWindowTitle(gameName) || !gameplayModes.Contains(currentMode))
                return;

            if (reset)
            {
                maxSpeed = 0;
                LabelMaxSpeed.Text = "Max Speed = " + maxSpeed.ToString();
                return;
            }

            try
            {
                if (float.Parse(currentEffectiveSpeedLabel.Text.Substring(17)) > maxSpeed)
                {
                    maxSpeed = float.Parse(currentEffectiveSpeedLabel.Text.Substring(17));
                    LabelMaxSpeed.Text = "Max Speed = " + maxSpeed.ToString();
                }
            }
            catch (FormatException)
            {
                LabelMaxSpeed.Text = "Max Speed = 0";
            }
        }

        /// <summary>
        /// Updates game status label (open/closed).
        /// </summary>
        private void UpdateStatus(bool gameOpen)
        {
            if (gameOpen)
            {
                LabelGameStatus.ForeColor = Color.Green;
                LabelGameStatus.Text = "Game Status: Open!";
            }
            else
            {
                LabelGameStatus.ForeColor = Color.Red;
                LabelGameStatus.Text = "Game Status: Closed!";
            }
        }

        /// <summary>
        /// Checks if the mode or music title has changed since last timer tick. Used to determine if 
        /// the UI needs updating.
        /// </summary>
        /// <returns>True if mode has changed, false if mode did not change.</returns>
        private bool GetMode()
        {
            string oldMusic = currentMusicTitle, oldMode = currentMode;
            string currMusic = memory.ReadString(GetPointer("CurrentMusicTitle")).ToLower();
            if (currMusic != "missionsucceed" && currMusic != "missionfail")
                currentMusicTitle = currMusic;
            bool musicFound = false;

            if (currentMode == "Items")
                return false; //return immediately if items are showing

            //Check each category of music titles for matches of currentMusicTitle
            for (int i = 0; i < musicTitles.Count; ++i)
            {
                if (musicTitles[i].IndexOf(currentMusicTitle) != -1) //if not found
                {
                    if (i == 9) //TyBunyip
                        currentMode = memory.ReadInt(GetPointer("CharacterState")) == 0 ? "Ty" : "Bunyip";
                    else if (i == 10) //TyTruck
                        currentMode = memory.ReadInt(GetPointer("CharacterState")) == 0 ? "Ty" : "Truck";
                    else
                        currentMode = modes[i];
                    musicFound = true;
                    break;
                }
            }

            if (memory.ReadInt(GetPointer("GameLoading")) == 1)
                currentMode = "Loading";

            if (!musicFound)
                currentMode = "Unknown";

            if (oldMode != currentMode)
            {
                Log($"Mode changed to {currentMode}.", "GAME", true);
                UpdateMaxSpeed(true); //reset max speed value to 0 on mode change
            }
               
            if (oldMusic != currentMusicTitle && oldMusic != "" && currentMusicTitle != "")
                Log($"Music changed to {musicTitleStrings[currentMusicTitle]}.", "GAME", true);

            return oldMode != currentMode;
        }

        /// <summary>
        /// Updates the "Current Area" and "Character State" label swith the current location/state of the player in-game.
        /// </summary>
        private void UpdateAreaState()
        {
            if (musicTitleStrings.ContainsKey(currentMusicTitle))
                LabelCurrentArea.Text = $"Current Area: {musicTitleStrings[currentMusicTitle]}";
            else
                LabelCurrentArea.Text = "Current Area: Unknown";

            string state = characterStateStrings[memory.ReadInt(GetPointer("CharacterState"))];
            LabelCharacterState.Text = "Character State: " + state;
        }

        /// <summary>
        /// Updates the UI by bringing different panels to the front, if needed.
        /// </summary>
        /// <param name="panel"></param>
        private void UpdateUI(Panel panel)
        {
            if (frontPanel.Name != "MainPanelItems" && frontPanel.Name != "MainPanelStartup")
            {
                //Unfreeze/uncheck and reset textboxes for clean swapping between modes
                foreach (CheckBox checkBox in frontPanel.GetAllNestedControls().OfType<CheckBox>().Where(check => check.Checked))
                {
                    string name = checkBox.Name.Substring(5);
                    if (!name.Contains("3D"))
                    {
                        Log($"Unfreezing {name}.", "FREEZE", false);
                        memory.UnfreezeValue(GetPointer(checkBox.Name.Substring(5)));
                    }
                    checkBox.Checked = false;
                    includeY = false;
                }

                foreach (TextBox textBox in frontPanel.GetAllNestedControls().OfType<TextBox>())
                    textBox.Text = "";
            }
            Log($"Bringing {panel.Name} to front.", "UI", false);
            panel.BringToFront();
            frontPanel = panel;
            if (gameplayModes.Contains(currentMode))
            {
                //update currentEffectiveSpeedLabel whenever panel changes to a gameplay mode
                currentEffectiveSpeedLabel = (Label)frontPanel.GetAllNestedControls().First(ctrl => ctrl.Name.Contains("EffectiveSpeed"));
                Log($"Updated currentEffectiveSpeedLabel to {currentEffectiveSpeedLabel.Name}.", "UI", true);
            }
            SetLastAction(Color.Green, "");
        }

        /// <summary>
        /// Changes the LastAction label to the given color and text value.
        /// </summary>
        /// <param name="color"></param>
        /// <param name="text"></param>
        private void SetLastAction(Color color, string text)
        {
            LabelLastAction.ForeColor = color;
            LabelLastAction.Text = text;
        }

        /// <summary>
        /// Updates all of the labels that are currently displaying. This only runs if the game 
        /// is in focus, to save resources.
        /// </summary>
        private void UpdateLabels()
        {
            if (!GetActiveWindowTitle(gameName))
                return;

            foreach (Label label in frontPanel.GetAllNestedControls().OfType<Label>())
            {
                if (label.Name.Contains("EffectiveSpeed"))
                {
                    double xSpeed = memory.ReadFloat(GetPointer(currentMode + "XSpeed"));
                    double zSpeed = memory.ReadFloat(GetPointer(currentMode + "ZSpeed"));
                    double speed = Math.Sqrt(Math.Pow(xSpeed, 2) + Math.Pow(zSpeed, 2));
                    if (includeY) //include ySpeed as 3rd dimension if needed
                    {
                        double ySpeed = memory.ReadFloat(GetPointer(currentMode + "YSpeed"));
                        speed = Math.Sqrt(Math.Pow(xSpeed, 2) + Math.Pow(ySpeed, 2) + Math.Pow(zSpeed, 2));
                    }
                    label.Text = "Effective Speed: " + speed.ToString("0.000");
                    continue;
                }
                else
                {
                    string key = label.Name.Substring(5), valueType = "";
                    if(pointerNames.FindIndex(findKey => findKey == key) != -1)
                        valueType = pointerTypes[pointerNames.FindIndex(findKey => findKey == key)];

                    if (valueType == "float")
                    {
                        float value = memory.ReadFloat(GetPointer(key));
                        label.Text = addressLabelStrings[key] + value;
                    }
                    else if (valueType == "int")
                    {
                        int value = memory.ReadInt(GetPointer(key));
                        label.Text = addressLabelStrings[key] + value;
                    }
                }
            }
        }

        /// <summary>
        /// Override of WndProc that specifies how to handle hotkey events based on the ID of the
        /// hotkey that was pressed by the user.
        /// </summary>
        /// <param name="m"></param>
        protected override void WndProc(ref Message m)
        {
            if (m.Msg == 0x0312 && GetActiveWindowTitle(gameName))
            {
                if (m.WParam.ToInt32() < 6)
                    AdjustValue(m.WParam.ToInt32());
                else if (m.WParam.ToInt32() == 6)
                    DisplayStoredPosition(this, EventArgs.Empty);
                else if (m.WParam.ToInt32() == 7)
                    UpdateStoredPosition(this, EventArgs.Empty);
                else if (m.WParam.ToInt32() == 8)
                    Teleport(this, EventArgs.Empty);
                else if (m.WParam.ToInt32() == 9)
                    UpdateMaxSpeed(true);
            }

            base.WndProc(ref m);
        }

        /// <summary>
        /// Adjusts the player's X/Y/Z position by the amount specified in App.config. Triggered by hotkeys.
        /// </summary>
        /// <param name="id"></param>
        private void AdjustValue(int id)
        {
            CheckXYZ("Can't use hotkey - no X/Y/Z value is showing!");
            Dictionary<int, string> idLookup = new Dictionary<int, string>()
            {
                { 0, "X" }, { 1, "X" }, { 2, "Y" }, { 3, "Y" }, { 4, "Z" }, { 5, "Z" }
            };
            string type = idLookup[id];
            float speed = 0, value;

            if (type == "X")
                speed = XSpeed;
            else if (type == "Y")
                speed = YSpeed;
            else if (type == "Z")
                speed = ZSpeed;

            if (id % 2 == 0) //even ids are "Less", odd ids are "More"
                value = memory.ReadFloat(GetPointer(currentMode + type)) - speed;
            else
                value = memory.ReadFloat(GetPointer(currentMode + type)) + speed;

            memory.WriteMemory(GetPointer(currentMode + type), "float", value.ToString());
        }

        /// <summary>
        /// Displays the currently stored position used for teleporting the player.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void DisplayStoredPosition(object sender, EventArgs e)
        {
            SetLastAction(Color.Green, $"Stored position: X={teleportX}, Y={teleportY}, Z={teleportZ}.");
        }

        /// <summary>
        /// Checks whether a valid panel is visible (one with XYZ values displaying), used before running
        /// methods that deal with setting or teleporting positions.
        /// </summary>
        /// <param name="message"></param>
        /// <returns></returns>
        private bool CheckXYZ(string message)
        {
            string[] noXYZ = { "Cutscene", "Items", "Other", "Unknown", "Closed", "Loading" };
            if (Array.IndexOf(noXYZ, currentMode) != -1)
            {
                SetLastAction(Color.Red, message);
                return false;
            }
            return true;

        }

        /// <summary>
        /// Sets/updates the stored XYZ position used for teleporting.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void UpdateStoredPosition(object sender, EventArgs e)
        {
            if (!CheckXYZ("Can't set position unless X/Y/Z coordinates are displaying!"))
                return;

            teleportX = memory.ReadFloat(GetPointer(currentMode + "X"));
            teleportY = memory.ReadFloat(GetPointer(currentMode + "Y"));
            teleportZ = memory.ReadFloat(GetPointer(currentMode + "Z"));

            Log($"Set position: X={teleportX}, Y={teleportY}, Z={teleportZ}.", "SET VALUE", false);
            SetLastAction(Color.Green, $"Set position: X={teleportX}, Y={teleportY}, Z={teleportZ}.");
        }

        /// <summary>
        /// Teleports the player to the stored XYZ position.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Teleport(object sender, EventArgs e)
        {
            if (!CheckXYZ("Can't teleport unless X/Y/Z coordinates are displaying!"))
                return;

            memory.WriteMemory(GetPointer(currentMode + "X"), "float", teleportX.ToString());
            memory.WriteMemory(GetPointer(currentMode + "Y"), "float", teleportY.ToString());
            memory.WriteMemory(GetPointer(currentMode + "Z"), "float", teleportZ.ToString());

            Log($"Teleported to: X={teleportX}, Y={teleportY}, Z={teleportZ}.", "TELEPORT", false);
            SetLastAction(Color.Green, $"Teleported to: X={teleportX}, Y={teleportY}, Z={teleportZ}");
        }

        /// <summary>
        /// Opens a help window that contains information about the value the clicked help button is
        /// associated with.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OpenHelp(object sender, EventArgs e)
        {
            int index = pointerNames.IndexOf(((Button)sender).Name.Substring(4));
            new HelpWindow(pointerNames[index], pointerTypes[index], helpTexts[index]).Show();
            Log($"Help button for {pointerNames[index]} was triggered.", "HELP", false);
        }

        /// <summary>
        /// Pre-processing to ensure that either the Enter or Return key was pressed. Sends the text box's
        /// contents into SetValue for further logic.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void CheckEnterKey(object sender, KeyPressEventArgs e)
        {
            if (e.KeyChar == (char)Keys.Enter || e.KeyChar == (char)Keys.Return)
                SetValue(((TextBox)sender).Text, ((Control)sender).Name.Substring(4));
        }

        /// <summary>
        /// Checks if a valid value was entered into the text box, and if so, writes it to memory.
        /// </summary>
        /// <param name="value"></param>
        /// <param name="name"></param>
        private void SetValue(string value, string name)
        {
            if (value == "")
            {
                Log("Error setting value - empty text box!", "WARNING", false);
                SetLastAction(Color.Red, "Can't set value - need a value in the text box!");
                return;
            }
            try
            {
                Log($"Writing {value} to {name}.", "SET VALUE", false);
                memory.WriteMemory(GetPointer(name), pointerTypes[pointerNames.IndexOf(name)], value);
                SetLastAction(Color.Green, $"Set {name} to {value}.");
            }
            catch (FormatException)
            {
                Log($"Error writing {value} to {name} - wrong type!", "WARNING", false);
                SetLastAction(Color.Red, "Can't set value - wrong type!");
            }
        }

        private void ToggleItems(object sender, EventArgs e)
        {
            CheckBox box = (CheckBox)sender;
            if (box.Checked)
            {
                currentMode = "Items";
                MainPanelItems.BringToFront();
                frontPanel = MainPanelItems;
            }
            else
                currentMode = "Unknown";
        }

        private void ResetMaxSpeed(object sender, EventArgs e)
        {
            maxSpeed = 0;
        }

        private void ToggleY(object sender, EventArgs e)
        {
            Log("Enabled including Y for Effective Speed calculations.", "INFO", false);
            includeY = !includeY;
        }

        /// <summary>
        /// Toggles a feature (such as Infinite Jump or Infinite Swim).
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ToggleFeature(object sender, EventArgs e)
        {
            string pointerName = ((CheckBox)sender).Name.Substring(5);
            if (((CheckBox)sender).Checked)
            {
                Log(featureNames[pointerName] + " activated.", "FREEZE", false);
                if (pointerName == "TyGroundedState")
                    memory.FreezeValue(GetPointer(pointerName), "int", "1");
                else if (pointerName == "TySwimmingState")
                    memory.FreezeValue(GetPointer(pointerName), "int", "0");
                SetLastAction(Color.Green, $"Activated {featureNames[pointerName]}.");
            }
            else
            {
                Log(featureNames[pointerName] + " deactivated.", "FREEZE", false);
                memory.UnfreezeValue(GetPointer(pointerName));
                SetLastAction(Color.Green, $"Deactivated {featureNames[pointerName]}.");
            }
        }

        /// <summary>
        /// Freezes and unfreezes values when a CheckBox is clicked. When freezing, the current value will 
        /// be frozen if there is nothing entered in the associated TextBox, otherwise the TextBox value 
        /// will be validated and frozen.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ToggleFreeze(object sender, EventArgs e)
        {
            string pointerName = ((CheckBox)sender).Name.Substring(5);
            if (!((CheckBox)sender).Checked) //unfreeze value
            {
                Log($"Unfreezing {pointerName}.", "FREEZE", false);
                memory.UnfreezeValue(GetPointer(pointerName));
                SetLastAction(Color.Green, $"Unfroze {pointerName}.");
                return;
            }

            TextBox textBox = (TextBox)frontPanel.Controls.Find("Text" + pointerName, true)[0];
            string type = pointerTypes[pointerNames.IndexOf(pointerName)];
            string value = textBox.Text;
            if (value == "") //freeze current value
            {
                if (type == "float")
                    value = memory.ReadFloat(GetPointer(pointerName)).ToString();
                else if (type == "int")
                    value = memory.ReadInt(GetPointer(pointerName)).ToString();
                Log($"Empty text box - freezing current value ({value}) to {pointerName}.", "FREEZE", false);
                memory.FreezeValue(GetPointer(pointerName), type, value);
                SetLastAction(Color.Green, $"Froze {value} to {pointerName}.");
            }
            else //freeze value in TextBox
            {
                bool success = true;
                if (type == "int" && !int.TryParse(textBox.Text, out _))
                    success = false;
                else if (type == "float" && !float.TryParse(textBox.Text, out _))
                    success = false;

                if (success)
                {
                    Log($"Freezing value {value} to {pointerName}.", "FREEZE", false);
                    memory.FreezeValue(GetPointer(pointerName), type, textBox.Text);
                    SetLastAction(Color.Green, $"Froze {value} to {pointerName}.");
                }
                else
                {
                    Log($"Error freezing value {value} to {pointerName} - wrong type!", "WARNING", false);
                    SetLastAction(Color.Red, $"Can't freeze {value} to {pointerName} - wrong type!");
                    ((CheckBox)sender).Checked = false;
                }
            }
        }

        /// <summary>
        /// Opens the Info Window, which displays Hotkey information as well as support information 
        /// (my Discord tag, GitHub link, etc.)
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void OpenInfoWindow(object sender, EventArgs e)
        {
            string text = "";
            for(int i = 0; i < customHotkeyList.Count; ++i)
                text += hotkeyNameList[i] + ": " + customHotkeyList[i] + "\r\n";
            new InfoWindow(text).Show();
        }

        /// <summary>
        /// Before closing, this method is triggered to ensure hotkeys are unregistered. In theory, it 
        /// should be impossible for hotkeys to still be registered when closing the trainer, but this 
        /// makes sure of it.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void CloseTasks(object sender, FormClosingEventArgs e)
        {
            for (int i = 0; i < hotkeyNameList.Count; ++i)
                UnregisterHotKey(this.Handle, i);
        }

        /// <summary>
        /// On trainer startup, this immediately starts the timer so there's no delay in processing game
        /// information.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void Form1_Shown(object sender, EventArgs e)
        {
            appTimer.Start();
        }
    }
}

namespace ControlExtension
{
    public static class ControlExtensions
    {
        public static IEnumerable<Control> GetAllNestedControls(this Control parent)
        {
            var stack = new Stack<Control>();
            foreach (Control child in parent.Controls)
                stack.Push(child);

            while (stack.Count > 0)
            {
                var control = stack.Pop();
                yield return control;

                foreach (Control child in control.Controls)
                    stack.Push(child);
            }
        }
    }
}